<!DOCTYPE html>
<html lang="fa">
<head>
<meta charset="UTF-8">
<title>Scan 2</title>
<style>
  body { font-family: Tahoma, sans-serif; padding: 20px; }
  h3 { margin-top: 20px; margin-bottom: 5px; }
  .checkbox-row { display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 10px; }
  .checkbox-row div { display: flex; align-items: center; gap: 3px; }
  table { border-collapse: collapse; margin-top: 20px; width: 100%; table-layout: fixed; }
  th, td { border: 1px solid #333; padding: 5px; text-align: center; vertical-align: top; font-size: 12px; }
  th { background-color: #000; color: #fff; position: sticky; z-index: 3; }
  tr:hover td { background-color: #000; color: #fff; }
  th.tf-top { top: 0; z-index: 5; }
  th.tf-bottom { top: 30px; z-index: 4; }
  td + td { border-left: 3px solid #000; }
</style>
</head>
<body>

<h2>انتخاب دسته‌بندی</h2>
<div id="categories" class="checkbox-row"></div>
<div>
  <input type="checkbox" id="all_categories"><label for="all_categories">All Categories</label>
</div>

<h3>تایم فریم‌ها</h3>
<div id="timeframes" class="checkbox-row"></div>

<h3>فیلدها</h3>
<div id="fields" class="checkbox-row"></div>

<button onclick="generateTable()">نمایش جدول</button>

<div id="result"></div>

<script>
const dataUrl = 'https://raw.githubusercontent.com/alalalk71/dine/refs/heads/main/data.json';
const timeframesList = ["1m","3m","5m","15m","30m","1h","2h","4h","6h","12h","1d","3d","1w"];
const fieldsList = ["cm55","m55","m200","cm200","dm","dr","mr","sros","srob","srd","cci14_ob","cci14_os","cci14_s","cci14_n","cci14_m","cci50_ob","cci50_os","cci50_s","cci50_n","cci50_m","obv_dn","obv_ds","obv_m"];

async function loadData() {
  const res = await fetch(dataUrl);
  return await res.json();
}

function createCheckbox(id, label) {
  const div = document.createElement('div');
  const cb = document.createElement('input');
  cb.type = 'checkbox';
  cb.id = id;
  const lbl = document.createElement('label');
  lbl.htmlFor = id;
  lbl.textContent = label;
  div.appendChild(cb);
  div.appendChild(lbl);
  return div;
}

async function init() {
  const data = await loadData();
  const catContainer = document.getElementById('categories');
  Object.keys(data).forEach(cat => {
    const cbDiv = createCheckbox('cat_' + cat, cat);
    catContainer.appendChild(cbDiv);
  });

  document.getElementById('all_categories').addEventListener('change', (e) => {
    const check = e.target.checked;
    document.querySelectorAll('#categories input[type=checkbox]').forEach(cb => {
      cb.checked = check;
      cb.disabled = check;
    });
  });

  const tfContainer = document.getElementById('timeframes');
  timeframesList.forEach(tf => {
    const cbDiv = createCheckbox('tf_' + tf, tf);
    tfContainer.appendChild(cbDiv);
  });

  const fieldContainer = document.getElementById('fields');
  fieldsList.forEach(f => {
    const div = document.createElement('div');
    const label = document.createElement('label');
    label.textContent = f;
    const cbTrue = document.createElement('input');
    cbTrue.type = 'checkbox';
    cbTrue.id = `field_${f}_true`;
    const cbFalse = document.createElement('input');
    cbFalse.type = 'checkbox';
    cbFalse.id = `field_${f}_false`;
    div.appendChild(label);
    div.appendChild(cbTrue);
    div.appendChild(document.createTextNode('✅'));
    div.appendChild(cbFalse);
    div.appendChild(document.createTextNode('❌'));
    fieldContainer.appendChild(div);
  });
}

function coinMatchesFilters(data, coin, selectedCats, selectedTFs, selectedFields) {
  // AND logic: must match ALL selectedTFs & fields
  for (const tf of selectedTFs) {
    for (const field of Object.keys(selectedFields)) {
      const requiredValue = selectedFields[field]; // true => ✅, false => ❌
      let matchInAnyCat = false;
      for (const cat of selectedCats) {
        if (data[cat] && data[cat][coin] && data[cat][coin][tf]) {
          const value = data[cat][coin][tf][field + '_fmt'];
          if ((requiredValue && value === '✅') || (!requiredValue && value === '❌')) {
            matchInAnyCat = true;
            break;
          }
        }
      }
      if (!matchInAnyCat) return false; // failed for this tf+field
    }
  }
  return true; // passed all
}

async function generateTable() {
  const data = await loadData();
  const resultContainer = document.getElementById('result');

  const selectedCats = Array.from(document.querySelectorAll('#categories input:checked')).map(cb => cb.id.replace('cat_',''));
  const selectedTFs = Array.from(document.querySelectorAll('#timeframes input:checked')).map(cb => cb.id.replace('tf_',''));

  const selectedFields = {};
  fieldsList.forEach(f => {
    const trueCB = document.getElementById(`field_${f}_true`);
    const falseCB = document.getElementById(`field_${f}_false`);
    if (trueCB.checked) selectedFields[f] = true;
    if (falseCB.checked) selectedFields[f] = false;
  });

  if(selectedCats.length === 0 || selectedTFs.length === 0 || Object.keys(selectedFields).length === 0){
    resultContainer.innerHTML = "<p>لطفاً حداقل یک دسته‌بندی، تایم‌فریم و فیلد انتخاب کنید.</p>";
    return;
  }

  let allCoins = new Set();
  selectedCats.forEach(cat => {
    if (data[cat]) Object.keys(data[cat]).forEach(coin => allCoins.add(coin));
  });

  allCoins = Array.from(allCoins).filter(coin => coinMatchesFilters(data, coin, selectedCats, selectedTFs, selectedFields));
  allCoins.sort();

  // Build table header
  let tableHTML = '<table><thead><tr><th class="tf-top" rowspan="2">کوین</th>';
  selectedTFs.forEach(tf => {
    tableHTML += `<th class="tf-top" colspan="${Object.keys(selectedFields).length}">${tf}</th>`;
  });
  tableHTML += '</tr><tr>';
  selectedTFs.forEach(() => {
    Object.keys(selectedFields).forEach(f => {
      tableHTML += `<th class="tf-bottom">${f}</th>`;
    });
  });
  tableHTML += '</tr></thead><tbody>';

  allCoins.forEach(coin => {
    tableHTML += `<tr><td>${coin}</td>`;
    selectedTFs.forEach(tf => {
      Object.keys(selectedFields).forEach(f => {
        let cell = '❌';
        for (const cat of selectedCats) {
          if (data[cat] && data[cat][coin] && data[cat][coin][tf] && data[cat][coin][tf][f+'_fmt']) {
            cell = data[cat][coin][tf][f+'_fmt'];
            break;
          }
        }
        tableHTML += `<td>${cell}</td>`;
      });
    });
    tableHTML += '</tr>';
  });

  tableHTML += '</tbody></table>';
  resultContainer.innerHTML = tableHTML;
}

init();
</script>
</body>
</html>
